#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S4,     ultrasonic,     sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     FRWheelMotor,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Brush,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FLWheelMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BLWheelMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     LLinear,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     Shooter,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     RLinear,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     BRWheelMotor,  tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    LTalon,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    BRHoodLeg,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    FLHoodLeg,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    BLHoodLeg,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    FRHoodLeg,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    RTalon,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"



int deadband(int x)
{
	if (x <= 10 && x >= -10)
		x = 0;
	return x;
}

int motorScale(float x)
{
	x = ((x / 128) * 100);
	if (x > 100)
		x = 100;
	return x;
}

void drive(int x, int y, int r)
{
	float k = 1.0;
	float kR = 1.0;

	int xPower, yPower, rPower, FLPower, BLPower, BRPower, FRPower;

	xPower = -k 	* motorScale(x);
	yPower = k 	* motorScale(y);
	rPower = kR	* motorScale(r);

	FLPower = motorScale(		xPower	+	yPower	+	rPower);
	BLPower = motorScale( -	xPower 	+	yPower	+	rPower);
	BRPower = motorScale(		xPower	+	yPower	-	rPower);
	FRPower = motorScale( -	xPower	+	yPower	-	rPower);

	motor[FLWheelMotor] = FLPower;
	motor[BLWheelMotor] = BLPower;
	motor[BRWheelMotor] = BRPower;
	motor[FRWheelMotor] = FRPower;
}

void dropTalons ()
{
	int RTalon = 31;	// smaller value is more down
	int LTalon = 248 - RTalon;

	servo[LTalon] = LTalon;
	servo[RTalon] = RTalon;
}

void liftTalons ()
{
	int RTalon = 250;  // greater value is more up
	int LTalon = 244 - RTalon;

	servo[LTalon] = LTalon;
	servo[RTalon] = RTalon;
}

bool checkDistance() // Check to see if robot is facing center goal.
{
	if (SensorValue[ultrasonic] < 60)
		return true;
	else return false;
}

void openGate()
{
	servo[gate] = 115;
}

void closeGate()
{
	servo[gate] = 155;
}

void raiseHood () // height in centimeters
{
	int power = 100;

	int positionLeft = 67; // smaller value is more up
	int positionRight = 255 - positionLeft;
	int positionLeftMid = 180;
	int positionRightMid = 255 - positionLeftMid;
	servoChangeRate[BLHoodLeg] = 3;
	servoChangeRate[BRHoodLeg] = 3;
	servoChangeRate[FLHoodLeg] = 2;
	servoChangeRate[FRHoodLeg] = 2;
	servo[BLHoodLeg] = positionRightMid; // offset was -59
	servo[BRHoodLeg] = positionRightMid;
	servo[FLHoodLeg] = positionLeftMid;
	servo[FRHoodLeg] = positionRightMid;
	wait1Msec(750);
	servo[BLHoodLeg] = positionRight - 98; // that one weird leg
	servo[BRHoodLeg] = positionRight;
	wait1Msec(750);
	servo[FLHoodLeg] = positionLeft;
	servo[FRHoodLeg] = positionRight;

	motor[LLinear] = - power;
	motor[RLinear] = power;
	wait1Msec(4000);
	motor[LLinear] = 0;
	motor[RLinear] = 0;
}

void centerRobotGoal()
{
	while(SensorValue[ultrasonic] > 40)
	{
		drive (0, -40, 0);
	}
	drive (0, 0, 0);
}

void finalCenterRobotGoal()
{
	while(SensorValue[ultrasonic] > 10)
	{
		drive (0, 10, 0);
	}
	drive (0, 0, 0);
}

void initializeRobot()
{
	closeGate();
}

task main()
{


raiseHood();

/*

	//waitForStart();   // wait for start of autonomous phase
	initializeRobot();

	drive(0, -100, 0); // drive forward
	wait1Msec(1300);
	drive(0, 0, 0); // stop robot
	if (checkDistance()) // check if goal is in first position
	{
		centerRobotGoal(); // *OPTIONAL* make sure robot is centered with the goal
		raiseHood(); // move hood to 120 mark (center goal height)
		finalCenterRobotGoal();
		openGate(); // Release balls
		//drive (100, 0, 0);
		//wait1Msec (700);
		//drive (0, 0, 0);
	}
	//wait1Msec(500);
	else
	{
	drive(76, 0, -24);
	wait1Msec(2500);



	//	drive(0, 0, 0); // stop robot

	//	if (checkDistance()) // check if goal is in second position
	//	{
	//		centerRobotGoal(); // *OPTIONAL* make sure robot is centered with the goal
	//		raiseHood(); // move hood to 120 mark (center goal height)
	//		openBallGate(); // Release balls
	//	}
	//	else
	//	{
	//		drive(100, 0, 50); // Drive in Circle
	//		wait1Msec(250);
	//		drive(0, 0, 0); // stop robot

	//		if (checkDistance()) // check if goal is in third position
	//		{
	//			centerRobotGoal(); // *OPTIONAL* make sure robot is centered with the goal
	//			setHoodHeight(120); // move hood to 120 mark (center goal height)
	//			openBallGate(); // Release balls
	//		}
	//	}
	}
*/
}
