#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          Claw,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorC,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    clawServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    armServo,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEADBAND_THRESHOLD 20       //*!!Define as 10*//
#define BOUND(x) (((x) > 100)? 100: ((x) < -100)? -100: (x))     //*!!Makes sure that the joystick is between -100 and 100 !!*//
#define DEADBAND(x) ((abs(x) >= DEADBAND_THRESHOLD)? x: 0)     //*!!If the joystick is between -10 and 10, it will be treated as 0 !!*//
#define SERVOBOUND(x) (((x) > 255 )? 255: ((x) < 0)? 0: (x))
#define NXTBOUND(x) (((x)<0)? 0: ((x)>105)? 105: (x))


#define TIME_INTERVAL 100
int arm_servo_angle = 0;
int arm_step_angle = 25;
int claw_servo_angle = 0;
int claw_step_angle = 0;

void main_wheel( int joy1_x1, int joy1_y1 )
{

   int drivePower = DEADBAND(joy1_x1);
   int turnPower  = DEADBAND(joy1_y1);

   motor[motorA] = BOUND(drivePower - turnPower);
   motor[motorB] = BOUND(drivePower + turnPower);
}

void central_motor( int joy1_x2 )
{
	int k=15; //higher = slower
	int rotatePower = DEADBAND(joy1_x2);
	motor[motorC] = BOUND(rotatePower/k);
}

void arm_motors( int joy1_y2 )
{
	int k=10; //bigger = slower
	int rotatePower = DEADBAND(joy1_y2);
	motor[motorD] = -BOUND(rotatePower/k);
}

void arm_servos ( int btn2, int btn4 )
{
	servoChangeRate[armServo] = 5;
	if ( btn2 == 1 )
		arm_servo_angle = arm_servo_angle + arm_step_angle;

	else if ( btn4 == 1 )
		arm_servo_angle = arm_servo_angle - arm_step_angle;

	servo[armServo] = SERVOBOUND(arm_servo_angle); //locked between 0 and 255

}



void claw_servo ( int hat )
{
	servoChangeRate[clawServo] = 10;

	if ( hat == 0 )
	{
		claw_servo_angle = claw_servo_angle + claw_step_angle;
	}
	else if ( hat == 4 )
	{
		claw_servo_angle = claw_servo_angle + claw_step_angle;
	}
}

void initializeRobot(){
	return;
}

#include "JoystickDriver.c"
task main()
{
		initializeRobot();

		waitForStart();

    while(true)
    {
        getJoystickSettings(joystick); // Update Buttons and Joysticks

        main_wheel( joystick.joy1_x1, joystick.joy1_y1 ); // do not change
 				central_motor( joystick.joy1_x2 ); // do not change
 				arm_motors( joystick.joy1_y2 ); //do not change
        arm_servos( joy2Btn(2), joy2Btn(4) );
        claw_servo( joystick.joy2_TopHat ); //do not change
 				wait1Msec(TIME_INTERVAL);
    }
}
