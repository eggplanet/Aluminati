#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          Claw,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorC,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    armServo,             tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEADBAND_THRESHOLD 20       //*!!Define as 10*//
#define BOUND(x) (((x) > 100)? 100: ((x) < -100)? -100: (x))     //*!!Makes sure that the joystick is between -100 and 100 !!*//
#define DEADBAND(x) ((abs(x) >= DEADBAND_THRESHOLD)? x: 0)     //*!!If the joystick is between -10 and 10, it will be treated as 0 !!*//
#define SERVOBOUND(x) (((x) > 255 )? 255: ((x) < 0)? 0: (x))
#define NXTBOUND(x) (((x)<0)? 0: ((x)>105)? 105: (x))


#define TIME_INTERVAL 100
int claw_servo_angle = 0;
int claw_step_angle = 25;


void main_wheel( int joy1_x1, int joy1_y1 )
{

   int drivePower = DEADBAND(joy1_x1);
   int turnPower  = DEADBAND(joy1_y1);

   motor[motorA] = BOUND(drivePower - turnPower);
   motor[motorB] = BOUND(drivePower + turnPower);
}

void central_motor( int joy1_x2 )
{
	int k=15; //higher = slower
	int rotatePower = DEADBAND(joy1_x2);
	motor[motorC] = BOUND(rotatePower/k);
}

void arm_motors( int joy1_y2 )
{
	int k=10; //bigger = slower
	int rotatePower = DEADBAND(joy1_y2);
	motor[motorD] = -BOUND(rotatePower/k);
}

void arm_servos ( int btn2, int btn4 )
{
	servoChangeRate[armServo] = 20;
	if ( btn2 == 1 )
	{
		claw_servo_angle = claw_servo_angle + claw_step_angle;
	} else
	if ( btn4 == 1 )
	{
		claw_servo_angle = claw_servo_angle - claw_step_angle;
	}
	servo[armServo] = SERVOBOUND(claw_servo_angle);
}


void moveServo(int sec, int power){
	servo[armServo] = 117 + power;
	wait1Msec(sec*1000);
	servo[armServo] = 117;
}


void claw_servo ( int hat )
{
	bFloatDuringInactiveMotorPWM = false;

	if ( hat == 0 )
	{
		motor[Claw] = -10;
	}
	else if ( hat == 4 )
	{
		motor[Claw] = 10;
	}
	else if ( hat == -1 )
	{
		motor[Claw] = 0;
	}
}

void initializeRobot(){
	return;
}

#include "JoystickDriver.c"
task main()
{
		initializeRobot();

		waitForStart();

		nMotorEncoder[Claw] = 0;

    while(true)
    {
        getJoystickSettings(joystick); // Update Buttons and Joysticks

        main_wheel( joystick.joy1_x1, joystick.joy1_y1 ); // do not change
 				central_motor( joystick.joy1_x2 ); // do not change
 				arm_motors( joystick.joy1_y2 ); //do not change
        arm_servos( joy2Btn(2), joy2Btn(4) ); //do not change
        claw_servo( joystick.joy2_TopHat ); //do not change
 				wait1Msec(TIME_INTERVAL);
    }
}
